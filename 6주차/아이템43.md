### 람다보다는 메서드 참조를 사용하라

**메서드 참조는 람다보다도 더 간결하게 만들 수 있습니다.  

```java
map.merge(key, 1, (count, incr)-> count+incr);
```
위 코드는 키가 맵안에 없다면 키와 숫자 1을 매핑하고, 이미 있다면 기존 매핑값을 증가시킵니다.  
매개변수 count와 incr는 크게 하는 일이 없습니다.  
자바 8에서 Integer 클래스는 이 람다와 기능이 같은 정적 메서드 sum을 제공하기 때문에 아래와 같이 수정하면 더 간결하게 바꿀 수 있습니다.  

```java
map.merge(key,1,Integer::sum);
```

매개변수 수가 늘어날수록 메서드 참조로 제거 할 수 있는 코드양이 늘어나겠지만,  
어떤 람다에서는 매개변수의 이름 자체가 프로그래머에게 좋은 가이드가 되기도 합니다.  
이런 경우라면 메서드 참조보다 람다가 더 읽거나 쓰기에 쉬울 수 있습니다.  

---
**람다가 할 수 없는 일은 메서드 참조로도 할 수 없습니다.**  

그렇더라도 메서드 참조가 보통 더 짧고 간결하므로, 람다로 구현했을 때 너무 길거나 복잡하다면 메서드 참조가 좋은 대안이 될 수 있습니다.  
즉 람다로 작성할 코드를 새로운 메서드에 담은 다음, 람다 대신 그 메서드 참조를 사용하는 방식입니다.  

때론 람다가 메서드 참조보다 간결할 때도 있습니다.  
주로 메서드와 람다가 같은 클래스에 있을때입니다.  

```java
service.execute(()->action());
```
위는 람다를 사용했을 경우고, 아래는 메서드 참조를 사용할 때입니다.  
```java
service.execute(아주길고크고복잡한클래스이름::action);
```

---
**메서드 참조의 5가지 유형**  

|메서드 참조 유형|예시|같은 기능을 하는 람다|
|--------------|------|----------------|
|정적|Integer::parseInt|str->Integer.parseInt(str)|
|한정적(인스턴스)|Instant.now()::isAfter|Instant then = Instant.now(); t->then.isAfter(t)|
|비한정적(인스턴스)|String::toLowerCase|str->str.toLowerCase()|
|클래스 생성자|TreeMap<K,V>::new|()->new TreeMap<K,V>|
|배열 생성자|int[]::new|len->new int[len]|

